#!/usr/bin/env python3
"""
Mobile/Tasker Bridge Server
Provides HTTP API endpoints for mobile interaction with the Nexus system
"""

import json
import logging
from datetime import datetime
from typing import Dict, Optional
from flask import Flask, request, jsonify
from flask_cors import CORS
import sqlite3
import os
import yaml
from functools import wraps

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MobileBridge:
    """HTTP API bridge for mobile/Tasker integration"""
    
    def __init__(self, config_path: str = "nexus_config.yaml"):
        self.config = self.load_config(config_path)
        self.app = Flask(__name__)
        CORS(self.app)
        
        # Database connection
        self.db_path = self.config.get('database_path', 'nexus_problems.db')
        
        self.auth_token = self.config.get("mobile_bridge", {}).get("auth_token")
        
        self.setup_routes()
    
    def load_config(self, config_path: str) -> Dict:
        """Load configuration from YAML file"""
        default_config = {
            'mobile_bridge': {
                'enable': True,
                'port': 8080,
                'auth_token': None
            }
        }
        
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                user_config = yaml.safe_load(f)
                default_config.update(user_config)
        
        return default_config
    
    def require_auth(self, f):
        """Decorator to require authentication token"""
    def require_auth(self, f):
        """Decorator to require authentication token"""
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if self.auth_token:
                token = request.headers.get("Authorization")
                if not token or token != f"Bearer {self.auth_token}":
                    return jsonify({'error': 'Authentication required'}), 401
            return f(*args, **kwargs)
        return decorated_function
        
        @self.app.route('/api/status', methods=['GET'])
        @self.require_auth
        def get_status():
            """Get current system status"""
            try:
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Get problem counts by status
                cursor.execute('''
                    SELECT status, COUNT(*) as count 
                    FROM problems 
                    GROUP BY status
                ''')
                status_counts = dict(cursor.fetchall())
                
                # Get current problem
                cursor.execute('''
                    SELECT id, title, url, priority, estimated_effort, actual_effort
                    FROM problems 
                    WHERE status = 'in_progress'
                    ORDER BY updated_at DESC
                    LIMIT 1
                ''')
                current_problem = cursor.fetchone()
                
                # Get recent activity
                cursor.execute('''
                    SELECT problem_id, start_time, end_time, notes, progress
                    FROM work_sessions
                    ORDER BY start_time DESC
                    LIMIT 5
                ''')
                recent_sessions = cursor.fetchall()
                
                conn.close()
                
                response = {
                    'status': 'running',
                    'timestamp': datetime.now().isoformat(),
                    'problem_counts': status_counts,
                    'current_problem': {
                        'id': current_problem[0],
                        'title': current_problem[1],
                        'url': current_problem[2],
                        'priority': current_problem[3],
                        'estimated_effort': current_problem[4],
                        'actual_effort': current_problem[5]
                    } if current_problem else None,
                    'recent_sessions': len(recent_sessions)
                }
                
                return jsonify(response)
                
            except Exception as e:
                logger.error(f"Error getting status: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/current_problem', methods=['GET'])
        @self.require_auth
        def get_current_problem():
            """Get detailed information about current problem"""
            try:
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                cursor.execute('''
                    SELECT id, title, description, source, url, priority, status,
                           created_at, updated_at, metadata, tags, estimated_effort, actual_effort
                    FROM problems 
                    WHERE status = 'in_progress'
                    ORDER BY updated_at DESC
                    LIMIT 1
                ''')
                problem = cursor.fetchone()
                
                if not problem:
                    return jsonify({'error': 'No current problem'}), 404
                
                # Get current session info
                cursor.execute('''
                    SELECT id, start_time, notes, progress
                    FROM work_sessions
                    WHERE problem_id = ? AND end_time IS NULL
                    ORDER BY start_time DESC
                    LIMIT 1
                ''', (problem[0],))
                session = cursor.fetchone()
                
                conn.close()
                
                response = {
                    'id': problem[0],
                    'title': problem[1],
                    'description': problem[2],
                    'source': problem[3],
                    'url': problem[4],
                    'priority': problem[5],
                    'status': problem[6],
                    'created_at': problem[7],
                    'updated_at': problem[8],
                    'metadata': json.loads(problem[9]),
                    'tags': json.loads(problem[10]),
                    'estimated_effort': problem[11],
                    'actual_effort': problem[12],
                    'current_session': {
                        'id': session[0],
                        'start_time': session[1],
                        'notes': session[2].split('\n') if session[2] else [],
                        'progress': session[3].split('\n') if session[3] else []
                    } if session else None
                }
                
                return jsonify(response)
                
            except Exception as e:
                logger.error(f"Error getting current problem: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/add_note', methods=['POST'])
        @self.require_auth
        def add_note():
            """Add a note to the current work session"""
            try:
                data = request.get_json()
                if not data or 'note' not in data:
                    return jsonify({'error': 'Note text required'}), 400
                
                note = data['note']
                timestamp = datetime.now().strftime('%H:%M')
                formatted_note = f"[{timestamp}] {note}"
                
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Get current session
                cursor.execute('''
                    SELECT id, notes FROM work_sessions
                    WHERE end_time IS NULL
                    ORDER BY start_time DESC
                    LIMIT 1
                ''')
                session = cursor.fetchone()
                
                if not session:
                    return jsonify({'error': 'No active work session'}), 404
                
                # Update session notes
                existing_notes = session[1] if session[1] else ""
                updated_notes = existing_notes + "\n" + formatted_note if existing_notes else formatted_note
                
                cursor.execute('''
                    UPDATE work_sessions 
                    SET notes = ? 
                    WHERE id = ?
                ''', (updated_notes, session[0]))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'note': formatted_note,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Error adding note: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/add_progress', methods=['POST'])
        @self.require_auth
        def add_progress():
            """Add progress update to current work session"""
            try:
                data = request.get_json()
                if not data or 'progress' not in data:
                    return jsonify({'error': 'Progress text required'}), 400
                
                progress = data['progress']
                timestamp = datetime.now().strftime('%H:%M')
                formatted_progress = f"[{timestamp}] {progress}"
                
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Get current session
                cursor.execute('''
                    SELECT id, progress FROM work_sessions
                    WHERE end_time IS NULL
                    ORDER BY start_time DESC
                    LIMIT 1
                ''')
                session = cursor.fetchone()
                
                if not session:
                    return jsonify({'error': 'No active work session'}), 404
                
                # Update session progress
                existing_progress = session[1] if session[1] else ""
                updated_progress = existing_progress + "\n" + formatted_progress if existing_progress else formatted_progress
                
                cursor.execute('''
                    UPDATE work_sessions 
                    SET progress = ? 
                    WHERE id = ?
                ''', (updated_progress, session[0]))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'progress': formatted_progress,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Error adding progress: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/complete_problem', methods=['POST'])
        @self.require_auth
        def complete_problem():
            """Mark current problem as completed"""
            try:
                data = request.get_json()
                completion_note = data.get('note', 'Completed via mobile interface') if data else 'Completed via mobile interface'
                
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Get current problem and session
                cursor.execute('''
                    SELECT p.id, ws.id as session_id
                    FROM problems p
                    JOIN work_sessions ws ON p.id = ws.problem_id
                    WHERE p.status = 'in_progress' AND ws.end_time IS NULL
                    ORDER BY ws.start_time DESC
                    LIMIT 1
                ''')
                result = cursor.fetchone()
                
                if not result:
                    return jsonify({'error': 'No active problem to complete'}), 404
                
                problem_id, session_id = result
                
                # End the work session
                end_time = datetime.now()
                cursor.execute('''
                    UPDATE work_sessions 
                    SET end_time = ?, progress = COALESCE(progress, '') || ?
                    WHERE id = ?
                ''', (end_time, f"\n[{end_time.strftime('%H:%M')}] {completion_note}", session_id))
                
                # Mark problem as completed
                cursor.execute('''
                    UPDATE problems 
                    SET status = 'completed', updated_at = ?
                    WHERE id = ?
                ''', (end_time, problem_id))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'problem_id': problem_id,
                    'completion_time': end_time.isoformat(),
                    'note': completion_note
                })
                
            except Exception as e:
                logger.error(f"Error completing problem: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/queue', methods=['GET'])
        @self.require_auth
        def get_queue():
            """Get list of queued problems"""
            try:
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                cursor.execute('''
                    SELECT id, title, priority, estimated_effort, source, url, tags
                    FROM problems 
                    WHERE status = 'queued'
                    ORDER BY priority DESC, created_at ASC
                    LIMIT 20
                ''')
                problems = cursor.fetchall()
                conn.close()
                
                queue = []
                for p in problems:
                    queue.append({
                        'id': p[0],
                        'title': p[1],
                        'priority': p[2],
                        'estimated_effort': p[3],
                        'source': p[4],
                        'url': p[5],
                        'tags': json.loads(p[6]) if p[6] else []
                    })
                
                return jsonify({'queue': queue, 'count': len(queue)})
                
            except Exception as e:
                logger.error(f"Error getting queue: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/start_problem', methods=['POST'])
        @self.require_auth
        def start_problem():
            """Start working on a specific problem"""
            try:
                data = request.get_json()
                if not data or 'problem_id' not in data:
                    return jsonify({'error': 'Problem ID required'}), 400
                
                problem_id = data['problem_id']
                
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Check if problem exists and is queued
                cursor.execute('''
                    SELECT id, title, status FROM problems WHERE id = ?
                ''', (problem_id,))
                problem = cursor.fetchone()
                
                if not problem:
                    return jsonify({'error': 'Problem not found'}), 404
                
                if problem[2] != 'queued':
                    return jsonify({'error': f'Problem status is {problem[2]}, not queued'}), 400
                
                # End any current session
                cursor.execute('''
                    UPDATE work_sessions 
                    SET end_time = ? 
                    WHERE end_time IS NULL
                ''', (datetime.now(),))
                
                # Update current problem status
                cursor.execute('''
                    UPDATE problems 
                    SET status = 'queued' 
                    WHERE status = 'in_progress'
                ''')
                
                # Start new problem
                cursor.execute('''
                    UPDATE problems 
                    SET status = 'in_progress', updated_at = ?
                    WHERE id = ?
                ''', (datetime.now(), problem_id))
                
                # Create new work session
                cursor.execute('''
                    INSERT INTO work_sessions (problem_id, start_time, notes, progress)
                    VALUES (?, ?, ?, ?)
                ''', (problem_id, datetime.now(), 
                      f"[{datetime.now().strftime('%H:%M')}] Started via mobile interface",
                      f"[{datetime.now().strftime('%H:%M')}] Problem started"))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'problem_id': problem_id,
                    'problem_title': problem[1],
                    'start_time': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Error starting problem: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/pause_session', methods=['POST'])
        @self.require_auth
        def pause_session():
            """Pause current work session"""
            try:
                data = request.get_json()
                pause_note = data.get('note', 'Session paused via mobile interface') if data else 'Session paused via mobile interface'
                
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                # Get current session
                cursor.execute('''
                    SELECT ws.id, ws.problem_id
                    FROM work_sessions ws
                    JOIN problems p ON ws.problem_id = p.id
                    WHERE ws.end_time IS NULL AND p.status = 'in_progress'
                    ORDER BY ws.start_time DESC
                    LIMIT 1
                ''')
                session = cursor.fetchone()
                
                if not session:
                    return jsonify({'error': 'No active session to pause'}), 404
                
                session_id, problem_id = session
                
                # End the session
                end_time = datetime.now()
                cursor.execute('''
                    UPDATE work_sessions 
                    SET end_time = ?, notes = COALESCE(notes, '') || ?
                    WHERE id = ?
                ''', (end_time, f"\n[{end_time.strftime('%H:%M')}] {pause_note}", session_id))
                
                # Set problem back to queued
                cursor.execute('''
                    UPDATE problems 
                    SET status = 'queued', updated_at = ?
                    WHERE id = ?
                ''', (end_time, problem_id))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'session_id': session_id,
                    'problem_id': problem_id,
                    'pause_time': end_time.isoformat(),
                    'note': pause_note
                })
                
            except Exception as e:
                logger.error(f"Error pausing session: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/api/chat', methods=['POST'])
        @self.require_auth
        def chat_with_ai():
            """Chat with AI about current problem"""
            try:
                data = request.get_json()
                if not data or 'message' not in data:
                    return jsonify({'error': 'Message required'}), 400
                
                message = data['message']
                
                # For now, return a mock response
                # In a real implementation, this would integrate with your AI service
                ai_response = f"AI Response to: {message}"
                
                # Log the chat interaction
                conn = self.get_db_connection()
                cursor = conn.cursor()
                
                cursor.execute('''
                    INSERT INTO chat_logs (problem_id, timestamp, message, sender, context)
                    VALUES (?, ?, ?, ?, ?)
                ''', (data.get('problem_id'), datetime.now(), message, 'user', 'mobile_chat'))
                
                cursor.execute('''
                    INSERT INTO chat_logs (problem_id, timestamp, message, sender, context)
                    VALUES (?, ?, ?, ?, ?)
                ''', (data.get('problem_id'), datetime.now(), ai_response, 'ai', 'mobile_chat'))
                
                conn.commit()
                conn.close()
                
                return jsonify({
                    'success': True,
                    'user_message': message,
                    'ai_response': ai_response,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Error in chat: {e}")
                return jsonify({'error': str(e)}), 500
        
        @self.app.route('/health', methods=['GET'])
        def health_check():
            """Health check endpoint"""
            return jsonify({
                'status': 'healthy',
                'timestamp': datetime.now().isoformat(),
                'service': 'nexus-mobile-bridge'
            })
    
    def run(self):
        """Run the mobile bridge server"""
        port = self.config.get('mobile_bridge', {}).get('port', 8080)
        
        logger.info(f"Starting Mobile Bridge Server on port {port}")
        if self.auth_token:
            logger.info("Authentication enabled")
        else:
            logger.warning("Authentication disabled - consider setting an auth token")
            logger.warning("Authentication disabled - consider setting an auth token")
        
        self.app.run(
            host='0.0.0.0',
            port=port,
            debug=False,
            threaded=True
        )

def main():
    """Main entry point for mobile bridge"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Nexus Mobile Bridge Server")
    parser.add_argument('--config', default='nexus_config.yaml', help='Configuration file path')
    parser.add_argument('--port', type=int, help='Override port from config')
    
    args = parser.parse_args()
    
    bridge = MobileBridge(args.config)
    
    if args.port:
        bridge.config['mobile_bridge']['port'] = args.port
    
    bridge.run()

if __name__ == "__main__":
    main()